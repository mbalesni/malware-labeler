#!/Users/macbook/anaconda3/bin/python

import json
import os
import hashlib
import time
import sys
from virus_total_apis import PublicApi as VirusTotalPublicApi
from dotenv import load_dotenv

load_dotenv()

PER_DAY_LIMIT = 1000
PER_MINUTE_LIMIT = 4
SLEEP_AFTER_REQUEST = 60 / 4
SLEEP_AFTER_DAY_LIMIT = 24 * 60 * 60

INPUT_DIR = os.getenv('INPUT_DIR') or './malware'
RESULTS_DIR = os.getenv('RESULTS_DIR') or './results'

def authenticate():
    try:
        API_KEY = os.getenv('API_KEY')
        return VirusTotalPublicApi(API_KEY)
    except:
        raise Exception('Provide API key in .env')

def list_hashes(dir_name):
    hashes = []
    for root, _, files in os.walk(dir_name):
        for f in files:
            if len(f) == 32: # md5 hash
                hashes.append(f)
    return hashes

def get_file_size(path):
    return os.stat(path).st_size

def save_requests_made(number):
    with open('.env', 'r+') as env_file:
        old_lines = env_file.readlines()
        new_lines = []
        for line in old_lines:
            if 'REQUESTS_MADE' in line:
                new_lines.append('REQUESTS_MADE=' + str(number) + '\n')
            else:
                new_lines.append(line)
        
        env_file.seek(0)
        env_file.truncate()
        env_file.writelines(new_lines)

def schedule_next_start(timestamp):
    with open('.env', 'r+') as env_file:
        old_lines = env_file.readlines()
        new_lines = []
        for line in old_lines:
            if 'NEXT_SCHEDULED_START' not in line:
                new_lines.append(line)
        
        new_lines.append('NEXT_SCHEDULED_START=' + str(timestamp) + '\n')
        
        env_file.seek(0)
        env_file.truncate()
        env_file.writelines(new_lines)

if __name__ == '__main__':

    try:

        vt = authenticate()

        hashes = list_hashes(INPUT_DIR)

        requests_made = int(os.getenv('REQUESTS_MADE'))
        scheduled_start = int(os.getenv('NEXT_SCHEDULED_START')) 

        if time.time() < scheduled_start:
            print(time.ctime() + ' [Announcement] Day limit reached. Sleeping for ' + '{:.2f}'.format((scheduled_start - time.time()) / 60 / 60) + ' hours')
            time.sleep(scheduled_start - time.time())

        if not os.path.exists(RESULTS_DIR):
            os.makedirs(RESULTS_DIR, exist_ok=True)

        for i, md5hash in enumerate(hashes):

            if (requests_made % PER_DAY_LIMIT) == 0 and (requests_made != 0):
                print(time.ctime() + ' [Announcement] Day limit reached. Sleeping for ' + str(SLEEP_AFTER_DAY_LIMIT / 60 / 60) + ' hours')
                
                requests_made = 0
                save_requests_made(requests_made)

                next_scheduled_start = time.time() + SLEEP_AFTER_DAY_LIMIT
                schedule_next_start(next_scheduled_start)

                time.sleep(SLEEP_AFTER_DAY_LIMIT)


            output_path = os.path.join(RESULTS_DIR, md5hash + '.json')

            if os.path.exists(output_path):
                continue

            response = vt.get_file_report(md5hash)
            requests_made += 1
            result = {}

            if response['response_code'] != 200:
                print(time.ctime() + ' [' + md5hash + '][' + str(i+1) + '] Error getting report. Saving empty result file... Requests made in day:' + str(requests_made) + '/' + str(PER_DAY_LIMIT))
            elif response['results']['response_code'] != 1:
                print(time.ctime() + ' [' + md5hash + '][' + str(i+1) + '] Not found. Saving empty result file... Requests made in day:' + str(requests_made) + '/' + str(PER_DAY_LIMIT))
            else:
                result['scans'] = response['results']['scans']
                result['detection_percentage'] = response['results']['positives'] / response['results']['total']
                print(time.ctime() + ' [' + md5hash + '][' + str(i+1) + '] Success. Requests made in day:' + str(requests_made) + '/' + str(PER_DAY_LIMIT))

            with open(output_path, 'w') as output_file:
                output_file.write(json.dumps(result))

            save_requests_made(requests_made)
            time.sleep(SLEEP_AFTER_REQUEST)

    except (KeyboardInterrupt):
        save_requests_made(requests_made)
        sys.exit(0)
    except Exception as err:
        raise